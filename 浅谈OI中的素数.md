# 0. 素数的定义

素数，又称质数，是当一个大于1的正整数x，对于任意一个严格小于它且大于1的自然数a,都不会被a整除。即

$$
\large{\forall 1 < a < x 且 a 与 x \in \mathbb{N^{+}}  ,x \bmod a \ne 0}
$$
我们则称x为素数。

# 1. 试除法

既然已经知道了素数的定义，那要怎么来判断素数呢？

最简单的，也是最直接的，是按照定义判断素数，即试除法。回顾第0节，如果我们要判断x是不是素数，只需**照着定义**，一个一个地看。很简单，直接贴代码：

```cpp
bool Is_prime(int x)
{
	if(x<=1)//不符合定义
            return false;
    for(int i=2;i<x;i++)
		if(x%i==0)//会被整除
			return false;
	return true;//全部符合
}
```

时间复杂度为$O(n)$。那能不能优化呢？答案是肯定的。只要把循环条件 `i<x`改成`i*i<=x` 即可，时间复杂度瞬间降至$O(\sqrt{n})$。

为什么呢？因为任意一个数$a$，如果大于$\sqrt{x}$，那么如果它**可以整除$\Large{\color{White}{x}}$**，那么一定有一个比它小的数$\Large{\color{White}{\frac{x}{a}}}$**也可以整除x**，在之前已经试过了，早就退出了。如果程序运行到这里（即`i`大于`x`的开方），说明**肯定没有别的数可以整除它**了，可以直接退出循环。至于为什么要改成**小于等于**，因为如果它是一个**完全平方数**，可能只有它的开方可以整除它，必须要试。

等等，还有一个优化大项。这一点不是用数论知识，而是用经验实现。自从读了小学，我们就知道个位是0、2、4、6、8的数是2的倍数，个位是0、5的数是5的倍数。根据这一点，我们就可以写出一个判断条件：

```cpp
int j=x%10;
if((j==0||j==4||j==6||j==8)||(x>9&&(j==2||j==5)))
	return false;//不是素数
```

这只是一个~~奇妓淫巧~~小优化，但可以大大提高运行速度。

# 2. 埃及筛法

##  求[2,n]内的所有素数

虽然试除法在判断单个数的时候比较高效，但如果“批量处理”，比如**求$\large{\color{White}[2，n]}$内的所有素数**。如果用试除法，实在太慢了。

埃及筛法是一种古老而又简单的方法，可以快速找出$[2,n]$内所有素数。它相当于淘汰赛，一开始队列中**有$\large{\color{White}[2，n]}$内所有正整数**。接下来，依次取出队列中的第一个元素，把**队列中所有可以被它整除的数筛掉**，以此类推，直到队列为空。此时所有素数**都在取出来的元素中**了。但实际实现中，我们用数组标记素数。贴代码：

```cpp
const int MAXN=1e7;//定义空间大小，这个数据规模约10MB
int prime[MAXN+5];//存放素数
bool visit[MAXN+5];//记录素数，false代表是素数
int E_sieve(int n)
{
	int k=0;
    for(int i=0;i<=n;i++)//初始化
    	visit[i]=false;
    for(int i=2;i*i<=n;i++)//i*i与试除法同理
		if(!visit[i])
		{
			prime[k++]=i;//存下素数
			for(int j=i*i;j<=n;j+=i)//i的倍数不是素数，i*i因为之前的都被筛掉了。
            	visit[j]=true;//筛掉
		}
    return k;//返回素数个数
}
```
时间复杂度：2的倍数被筛掉，循环$n \div 2$次；3的倍数被筛掉，循环$n \div 3$次；5的倍数被筛掉，循环$n \div 5$次......以此类推，总次数为
$$
O(\frac{n}{2}+\frac{n}{3}+\frac{n}{5}+...+\frac{n}{\sqrt{n}})
$$
化简可得$O(n \log \log n)$（具体不作说明）。

空间复杂度：如果只用`visit`数组，当`MAXN`等与 $10^7$时约 10MB  。一般题目会限制空间为 65MB ,所以**`n`不可以再大了**。

##  求[a,b]内的所有素数

我们来看一下，如果问题**不要**我们求 $[2,a)$ 内的所有素数，而是求$[a,b]$,比如范围是$a<b<=10^{12},b-a<=10^6$,**正好超过**了$[2,n]$方法可以解决的范围，那怎么办呢？这就要用到**大区间素数的计算**了。

前文提到，用试除法判断n是不是素数，原理为：如果**它不能整除 $\large{\color{White}[2 , \sqrt{n}]}$ 内的所有素数，他就是素数**。根据埃及筛法更容易理解此原理：$[2,\sqrt{n}]$内的非合数$b$肯定对应了一个比它小的素数$a$。再用试除法的时候，如果$n$能整除$a$，已经证明了$n$不是素数，$b$就不用再试了。**也就是说，一个合数，一定有一个可以整除它的素数比它的开方小，我们只要筛出2~它的开方内的素数即可判断它是不是素数**。

此原理可以用来理解大区间素数问题。先用**埃及筛法求$\large{\color{White}{[2,sqrt(b)]}}$内的素数**，然后用这些素数来**筛[a,b]区间内的素数**即可。代码几乎就是两段埃及筛。

时间复杂度：$O(\sqrt{b}\log\log \sqrt{b}+(b-a)\sqrt{b-a})$

空间复杂度：$O(\sqrt{b}+(b-a))$

埃及筛法不错，但做了一些无用功：**某个数会被筛好几次**。比如$12$，会被$2$和$3$筛两次。尽管如此，一般情况下，埃及筛法也够用了。

# 3.欧拉筛（线性筛）

下面就是目前最快的欧拉筛了！！！二话不说，先贴代码：

```cpp
const int maxn = 101;   // 表长
int prime[maxn], pNum = 0;    // prime记录素数，pNum记录素数个数 
bool p[maxn] = {false};        // p记录当前数是否被筛去
void eulerSieve(int n)    // 查找记录2-n的素数
{
    for (int i = 2; i <= n; i++)
    {
    	cout<<" i = "<<i<<endl;
        if (!p[i])  // 如果未被筛过，则为素数
            prime[pNum++] = i;
        for (int j = 0; j < pNum&&i*prime[j]<=n; j++)
        {
            cout<<"  j = "<<j<<" prime["<<j<<"]"<<" = "<<prime[j]<<" i*prime[j] = "<<i*prime[j]<<endl;
            p[i * prime[j]] = true;     // 将已经记录的素数的倍数进行标记
            if (i % prime[j] == 0)      //关键步骤
                break;
        }
    }
}
```

之所以被称为线性筛，不是没原因的——因为**它的时间复杂度为$\large{\color{White}O(n)}$** ！！！它正好解决了上面埃及筛的“多余操作问题”，每个非素数只筛一次！！**其核心思想是把一个合数拆成一个合数乘它最小的质因子**。这究竟是如何实现的呢？我们一句句来分析。

第一句值得注意的，是`if(!p[i])prime[pNum++]=i;`。和埃及筛不同，它不是只用素数筛，**合数也可以用来筛**，所以不会跳出，但如果是**素数一定要记录**，这和埃及筛不同。下一句是内层for循环。循环条件为`j <= pNum && i * prime [j] <=maxn`,从下文看，**`j` 就是代表遍历整个素数数组的下标**，所以第一句很好理解，而第二句则是避免越界。

关键就在于最后一个`if`语句。为什么`i`能整除第`j`个素数时就要跳出循环？这肯定是**针对`i`是合数的情况**的。各位想一下，如果`i`是个合数，比如$9$，第一次循环`prime [j] =2`，筛掉$18$；第二次循环，`prime [j] =3`，筛掉$27$，然后被终止了；如果有第三次，`prime [j] =5`，筛掉$45$。注意！$45$最小的质因子是$3$，不是$5$，违背了核心思想，**会导致重复**。那为什么这句不符合就说明下一个数一定有更小的质因子呢？先假设素数$p$是一个合数的最小质因子，且此时满足`if`语句中的条件，则$m$乘$x^2$为此合数。下一个素数我们虽然不知道是几，但一定比$p$大，那下一个合数就是$m \times x \times 下一个素数$,**x肯定是这个合数的更小的质因子**。

时间复杂度：$O(n)$

空间复杂度：$O(n)$

欧拉筛比埃及筛快，但比较复杂，比赛时不到万不得已，建议不要使用，毕竟正确率第一嘛（我至今也难以默写欧拉筛）。

# 4.特大素数的判定

各位注意啦！如果你要判断的素数大到了天文数字，试除法难以运用，那么要好好学习此节！

听说过费马小定律吗？我们现在要用到的就是这一段：

$$
\forall a和p \in \mathbb{N^+}且p为素数且(a,p)=1,\\
a^{p-1}\equiv1\pmod{p}
$$


其中p是一个素数，翻译成人话是：**假如p是质数，且a,p互质，那么 a的(p-1)次方除以p的余数恒等于1**。证明见[知乎](https://zhuanlan.zhihu.com/p/87611586)。当然，我们不用把所有和要求的数互质的数全试一遍，只要**随机试几次**即可，据验证正确率极高。但要注意的是，这是费马小定律的反定律，是**不完全的**，有疏忽。这些可以逃过检测的数被称为**卡迈克尔数（Carmichael Number）**，最小的卡迈克尔数为561。为了提高正确率，我们要引入**二次探测定理**：

$$
x^2 \equiv 1 \pmod{p}
$$


此方程**有且仅有两个解**：$x_1=1,x_2=p-1$。证明见[这篇博客](https://blog.csdn.net/qq_41791981/article/details/81944696)。也就是说，在费马小定律之后，再用二次探测定律，随机生成多个x，进行试验，**如果发现在上面两个解之外还有解，即可判断它是合数**。一般要试8次才可以保证正确。代码如下：

```cpp
long long gcd(long long a,long long b)
{
	if(b==0)
		return a;
	return gcd(b,a%b);
}
long long fast_pow(long long base,long long index,long long mod)
{
	long long ans=1;
	while(index)
	{
		if(index&1)
			ans=(ans*base)%mod;
		base=(base*base)%mod;
		index>>=1;
	}
	return ans;
}
bool prime(long long a)//用费马小定律判断素数。 
{
	int r,t=30;
	long long ans;
	srand(time(NULL));
	while(t--)//30组测试数据 
	{
		r=rand();
		if(r%a==0)//注意这里！！！
		{
			t++;
			continue;
		}
		if(gcd(r,a)!=1)//非互质，不是素数 
			return false;
		ans=fast_pow(r,a-1,a);
		if(ans!=1)
			return false;
	}
	t=30;
	while(t--)//二次探测定律
	{
		r=rand()*rand()%a;
		r++;
		if(r==a-1||r==1)
		{
			t++;
			continue;
		}
		ans=fast_pow(r,2,a);
		if(ans==1)
			return false;
	}
	return true;
}
```
其实我在代码里加入了一个小小的优化：
```cpp
if(gcd(r,a)!=1)//非互质，不是素数 
			return false;
```

这让运行速度飞一样地提升。

但是要注意，这样的话，前面的if语句会出现bug，所以**需要修改**！！！

另外我还发现二次探测定律似乎不想理论上那么好使，所以我没有只试8次，试了30次，求哪位神犇帮我做个解释。

------------------------

#  last更新日志

+ 2021-7-26 写到埃及筛法并初步发表。
+ 2021-8-15 加入了欧拉筛和费马小定律判断素数。
+ 2021-9-10 加入了一些优化。
+ 2021-9-20 修复了费马小定律的**bug**(请读者们重新看我的文章和代码）。
+ 2022-7-29  重构了文章。

肝文不易，求点赞、关注加上机^_^。

注：本文借鉴了《算法竞赛入门与进阶》一书与[这篇博客](https://www.jianshu.com/p/2031036dba4b)，特此鸣谢。